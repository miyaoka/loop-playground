<!doctype html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Loop Animation</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: system-ui, sans-serif;
        padding: 40px;
        background: #f5f5f5;
      }

      /* ヘッダー */
      .header {
        display: flex;
        align-items: center;
        gap: 20px;
        margin-bottom: 20px;
      }

      .header h1 {
        margin: 0;
      }

      .header-nav {
        display: flex;
        gap: 16px;
      }

      .header-nav a.active {
        color: inherit;
        text-decoration: none;
      }

      .header-menu {
        display: flex;
        gap: 10px;
      }

      .header-menu button {
        padding: 8px 16px;
        border: 1px solid #ddd;
        border-radius: 4px;
        background: #fff;
        cursor: pointer;
      }

      .header-menu button.active {
        background: #667eea;
        color: white;
        border-color: #667eea;
      }

      h2 {
        margin: 20px 0 10px;
      }

      /* 縦並びレイアウト */
      .compare {
        display: flex;
        flex-direction: column;
        gap: 20px;
        margin-bottom: 40px;
      }

      .compare-item h3 {
        margin-bottom: 10px;
      }

      /* ループコンテナ（共通スタイル） */
      .loop,
      .loop-static {
        display: flex;
        width: var(--loop-width, 100%);
        max-width: 100%;
        overflow: hidden;
        background: #fff;
        border: 1px solid #ddd;
        border-radius: 8px;
        position: relative;
      }

      /* スクロールするトラック */
      .loop-track {
        position: relative;
        display: flex;
        animation: scroll var(--duration, 10s) linear infinite;
      }

      /* cloneは親の幅分右にオフセット */
      .loop-clone {
        position: absolute;
        left: 100%;
        top: 0;
        display: flex;
      }

      @keyframes scroll {
        0% {
          transform: translateX(0);
        }
        100% {
          transform: translateX(-100%);
        }
      }

      /* アイテムのスタイル（デモ用） */
      .item {
        flex-shrink: 0;
        padding: 20px 40px;
        margin: 10px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border-radius: 8px;
        font-weight: bold;
        white-space: nowrap;
      }

      button.item {
        border: none;
        cursor: pointer;
      }

      /* ホバーで一時停止 */
      .loop:hover .loop-track {
        animation-play-state: paused;
      }

      /* デバッグ用：cloneされた要素を薄く表示 */
      .loop-clone .item {
        opacity: 0.4;
      }
    </style>
  </head>
  <body>
    <div class="header">
      <h1>Loop Animation Demo</h1>
      <nav class="header-nav">
        <a href="index.html" class="active">通常版</a>
        <a href="webcomponent.html">Web Component版</a>
      </nav>
      <div class="header-menu">
        <button id="width-100" class="active">100%</button>
        <button id="width-500">500px</button>
        <button id="width-fit">fit-content</button>
      </div>
    </div>

    <div id="patterns">
      <!-- 基本 -->
      <div class="loop-static" data-label="基本（テキストのみ）">
        <div class="item">Item 1</div>
        <div class="item">Item 2</div>
        <div class="item">Item 3</div>
        <div class="item">Item 4</div>
        <div class="item">Item 5</div>
      </div>

      <!-- 雑多なコンテンツ -->
      <div class="loop-static" data-label="雑多なコンテンツ">
        <div class="item">テキストアイテム</div>
        <div class="item">
          <img
            src="https://picsum.photos/640/200"
            alt="sample image"
            style="display: block; border-radius: 4px"
          />
        </div>
        <div class="item" style="padding: 10px">
          <iframe
            width="560"
            height="315"
            src="https://www.youtube.com/embed/GQigLJ6iV4Y?si=Zgzs1CVpn43QP3D4"
            title="YouTube video player"
            frameborder="0"
            allow="
              accelerometer;
              autoplay;
              clipboard-write;
              encrypted-media;
              gyroscope;
              picture-in-picture;
              web-share;
            "
            referrerpolicy="strict-origin-when-cross-origin"
            allowfullscreen
          ></iframe>
        </div>
        <div class="item">短い</div>
        <div class="item" style="width: 200px">
          <p style="margin: 0">
            長めのテキストコンテンツ。複数行になる場合のテスト。
          </p>
        </div>
        <div class="item">
          <img
            src="https://picsum.photos/80/80"
            alt="square image"
            style="display: block; border-radius: 4px"
          />
        </div>
      </div>

      <!-- コンテンツが少ない場合 -->
      <div
        class="loop-static"
        data-label="コンテンツが少ない場合"
        data-scroll="50"
      >
        <div class="item">Only One</div>
      </div>

      <!-- コンテンツが少ない場合（充填モード） -->
      <div
        class="loop-static"
        data-label="コンテンツが少ない場合（充填モード）"
        data-scroll="50"
        data-fill
      >
        <div class="item">Only One</div>
      </div>

      <!-- コンテンツが多い場合（逆方向） -->
      <div
        class="loop-static"
        data-label="コンテンツが多い場合（逆方向）"
        data-scroll="-200"
      >
        <div class="item">A</div>
        <div class="item">B</div>
        <div class="item">C</div>
        <div class="item">D</div>
        <div class="item">E</div>
        <div class="item">F</div>
        <div class="item">G</div>
        <div class="item">H</div>
        <div class="item">I</div>
        <div class="item">J</div>
      </div>

      <!-- 動的コンテンツ（テキスト） -->
      <div
        class="loop-static"
        data-label="動的コンテンツ（テキスト）"
        id="dynamic-container"
      >
        <div class="item">Static</div>
        <div class="item" id="dynamic-item">Loading...</div>
        <div class="item">Static</div>
      </div>

      <!-- クリックイベント -->
      <div
        class="loop-static"
        data-label="クリックイベント"
        id="click-container"
      >
        <button class="item" id="btn-1">Button 1</button>
        <button class="item" id="btn-2">Button 2</button>
        <button class="item" id="btn-3">Button 3</button>
      </div>
    </div>

    <script>
      // 現在の幅設定
      let currentWidth = "100%";
      // デフォルトのスクロール速度（px/秒）
      const DEFAULT_SCROLL_SPEED = 100;
      // 全ループの updateLayout 関数を保存
      const updateLayoutFns = [];

      function initLoop(container, originalItems) {
        const items = Array.from(container.children);

        // スクロール速度を取得（data-scroll属性、px/秒）
        const scrollSpeed =
          parseFloat(container.dataset.scroll) || DEFAULT_SCROLL_SPEED;

        // 充填モードを取得（data-fill属性）
        const isFillMode = container.dataset.fill !== undefined;

        // トラック要素を作成
        const track = document.createElement("div");
        track.className = "loop-track";

        // オリジナル要素をトラックに移動（ベースアイテムとして保存）
        const baseItems = [];
        items.forEach((item, index) => {
          item.dataset.baseItem = "true";
          baseItems.push(item);
          track.appendChild(item);
          // クリックイベントをオリジナルにバイパス
          if (originalItems) {
            item.addEventListener("click", (e) => {
              e.stopPropagation();
              originalItems[index]?.click();
            });
          }
        });

        // トラックをコンテナに追加（幅計測のため先に追加）
        container.appendChild(track);

        // clone用のコンテナを作成
        const cloneContainer = document.createElement("div");
        cloneContainer.className = "loop-clone";
        track.appendChild(cloneContainer);

        // 前回の幅を保存（無限ループ防止）
        let lastTrackWidth = 0;

        // クリックイベントをバイパスするヘルパー
        function addClickBypass(element, index) {
          if (originalItems) {
            element.addEventListener("click", (e) => {
              e.stopPropagation();
              originalItems[index % originalItems.length]?.click();
            });
          }
        }

        // 幅とcloneを更新する関数
        function updateLayout() {
          // 一時的にcloneを空にして幅を計測
          cloneContainer.innerHTML = "";
          track.style.width = "";

          // fill用クローンを削除
          track.querySelectorAll("[data-fill-clone]").forEach((el) => el.remove());

          // ベースアイテムの実際の幅を計算
          let baseItemsWidth = 0;
          baseItems.forEach((item) => {
            const style = getComputedStyle(item);
            baseItemsWidth +=
              item.offsetWidth +
              parseFloat(style.marginLeft) +
              parseFloat(style.marginRight);
          });

          const containerWidth = container.clientWidth;
          const isFitContent = currentWidth === "fit-content";

          // 充填モード: コンテナを埋めるまでアイテムを繰り返す
          let trackWidth = baseItemsWidth;
          if (isFillMode && !isFitContent && baseItemsWidth < containerWidth) {
            const repeatCount = Math.ceil(containerWidth / baseItemsWidth);
            // 繰り返し分のクローンを追加（1回目はベースアイテムなので2回目から）
            for (let r = 1; r < repeatCount; r++) {
              baseItems.forEach((item, index) => {
                const fillClone = item.cloneNode(true);
                fillClone.dataset.fillClone = "true";
                delete fillClone.dataset.baseItem;
                addClickBypass(fillClone, index);
                track.insertBefore(fillClone, cloneContainer);
              });
            }
            trackWidth = baseItemsWidth * repeatCount;
          } else if (!isFitContent) {
            trackWidth = Math.max(containerWidth, baseItemsWidth);
          }

          // スクロール速度からdurationを計算（幅 / 速度 = 秒）
          const duration = trackWidth / Math.abs(scrollSpeed);
          const isReverse = scrollSpeed < 0;

          // 幅が変わっていなければスキップ
          if (trackWidth === lastTrackWidth) {
            // cloneだけ再作成
            const currentItems = track.querySelectorAll(":scope > .item");
            currentItems.forEach((item, index) => {
              const clone = item.cloneNode(true);
              addClickBypass(clone, index);
              cloneContainer.appendChild(clone);
            });
            track.style.width = `${trackWidth}px`;
            track.style.animationDuration = `${duration}s`;
            track.style.animationDirection = isReverse ? "reverse" : "normal";
            return;
          }
          lastTrackWidth = trackWidth;

          // cloneを再作成
          const currentItems = track.querySelectorAll(":scope > .item");
          currentItems.forEach((item, index) => {
            const clone = item.cloneNode(true);
            addClickBypass(clone, index);
            cloneContainer.appendChild(clone);
          });

          // 幅を設定
          track.style.width = `${trackWidth}px`;
          cloneContainer.style.left = `${trackWidth}px`;
          track.style.animationDuration = `${duration}s`;
          track.style.animationDirection = isReverse ? "reverse" : "normal";
        }

        // 初回レイアウト
        updateLayout();

        // ResizeObserver でサイズ変更を監視
        const resizeObserver = new ResizeObserver(() => {
          updateLayout();
        });

        // 各アイテムを監視
        track.querySelectorAll(":scope > .item").forEach((item) => {
          resizeObserver.observe(item);
        });

        // コンテナも監視（幅変更時）
        resizeObserver.observe(container);

        // MutationObserver でコンテンツ変更を監視
        const mutationObserver = new MutationObserver(() => {
          updateLayout();
        });
        track.querySelectorAll(":scope > .item").forEach((item) => {
          mutationObserver.observe(item, {
            childList: true,
            subtree: true,
            characterData: true,
          });
        });

        // updateLayout を外部から呼べるように保存（キャッシュリセット付き）
        updateLayoutFns.push(() => {
          lastTrackWidth = 0;
          updateLayout();
        });
      }

      // .loop-static からスクロール版を生成して縦並びにする
      function createCompareLayout(staticContainer) {
        const label = staticContainer.dataset.label;
        const originalItems = Array.from(
          staticContainer.querySelectorAll(".item"),
        );
        const parent = staticContainer.parentNode;
        const nextSibling = staticContainer.nextSibling;

        // 縦並びレイアウト
        const compare = document.createElement("div");
        compare.className = "compare";

        // オリジナル
        const originalItem = document.createElement("div");
        originalItem.className = "compare-item";
        const originalTitle = document.createElement("h3");
        originalTitle.textContent = "オリジナル";
        originalItem.appendChild(originalTitle);
        originalItem.appendChild(staticContainer);
        compare.appendChild(originalItem);

        // スクロール版
        const scrollItem = document.createElement("div");
        scrollItem.className = "compare-item";
        const scrollTitle = document.createElement("h3");
        scrollTitle.textContent = "スクロール";
        scrollItem.appendChild(scrollTitle);

        const loopContainer = staticContainer.cloneNode(true);
        loopContainer.className = "loop";
        loopContainer.removeAttribute("id");
        loopContainer.removeAttribute("data-label");
        loopContainer
          .querySelectorAll("[id]")
          .forEach((el) => el.removeAttribute("id"));
        scrollItem.appendChild(loopContainer);
        compare.appendChild(scrollItem);

        // h2を生成
        const h2 = document.createElement("h2");
        h2.textContent = label;

        // 元の位置に挿入
        parent.insertBefore(h2, nextSibling);
        parent.insertBefore(compare, nextSibling);

        // スクロール版を初期化
        initLoop(loopContainer, originalItems);
      }

      // 幅を切り替える
      function setLoopWidth(width) {
        currentWidth = width;
        document.documentElement.style.setProperty("--loop-width", width);

        // ボタンのactive状態を更新
        document
          .getElementById("width-100")
          .classList.toggle("active", width === "100%");
        document
          .getElementById("width-500")
          .classList.toggle("active", width === "500px");
        document
          .getElementById("width-fit")
          .classList.toggle("active", width === "fit-content");

        // 全ループを再計算
        updateLayoutFns.forEach((fn) => fn());
      }

      // DOM解析完了後に初期化（画像ロード前に実行される）
      document.addEventListener("DOMContentLoaded", () => {
        document.querySelectorAll(".loop-static").forEach(createCompareLayout);

        // 幅切り替えボタン
        document
          .getElementById("width-100")
          .addEventListener("click", () => setLoopWidth("100%"));
        document
          .getElementById("width-500")
          .addEventListener("click", () => setLoopWidth("500px"));
        document
          .getElementById("width-fit")
          .addEventListener("click", () => setLoopWidth("fit-content"));
      });

      // 3秒後に動的にテキストを設定（API取得を模擬）
      setTimeout(() => {
        const longText =
          "これはAPIから取得した長いテキストです。動的に設定されます。";
        const dynamicItem = document.getElementById("dynamic-item");
        if (dynamicItem) {
          dynamicItem.textContent = longText;
        }
      }, 3000);

      // ボタンのクリックイベント
      document
        .getElementById("btn-1")
        ?.addEventListener("click", () => alert(1));
      document
        .getElementById("btn-2")
        ?.addEventListener("click", () => alert(2));
      document
        .getElementById("btn-3")
        ?.addEventListener("click", () => alert(3));
    </script>
  </body>
</html>
